# copyright:
#   author: Peter Ritchie
#   file: determine-next-release-version.yaml
#   description: >
#     A reusable GitHib workflow that works with a repo Releases to determine
#     what the next version should be.
#   License: MIT
#   statement: >
#     Copyright (c) 2025 Peter Ritchie. All rights reserved.
#     Permission is hereby granted, free of charge, to any person obtaining a
#     copy of this software and associated documentation files (the
#     "Software"), to deal in the Software without restriction, including
#     without limitation the rights to use, copy, modify, merge, publish,
#     distribute, sublicense, and/or sell copies of the Software, and to
#     permit persons to whom the Software is furnished to do so, subject to
#     the following conditions:
#
#     The above copyright notice and this permission notice shall be included
#     in all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
#     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
#     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
#     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# If the last Release version tag is not in the form vA.B.C, where
# A, B, and C are numbers (1 or more digits) the workflow will report
# an error.
# The work flow has a single output with the version number (without
# a leading 'v') and can be obtained within a calling workflow
# with a statement similar to:
# $${{ needs.determine_next_release_version.outputs.version }}
---
name: Determine next Release version number

on:  # yamllint disable-line rule:truthy
  workflow_call:
    secrets:
      token:
        required: true
    outputs:
      version:
        description: the version number that was determined
        value: ${{ jobs.determine_next_release_version.outputs.version}}
      current_version:
        description: the current version number
        value: ${{ jobs.determine_next_release_version.outputs.current_version}}
    inputs:
      logLevel:
        description: 'Log level'
        required: false
        default: 'none'
        type: string

  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: false
        default: 'info'  # if running manually, probably looking for info.
        type: choice
        options: [none, info, warning, debug]

env:
  DEFAULT_MAJOR_VERSION: 0
  DEFAULT_MINOR_VERSION: 1
  DEFAULT_PATCH_VERSION: 0

jobs:
  determine_next_release_version:
    runs-on: ubuntu-latest
    name: Determine next Release version
    outputs:
      version: ${{ steps.determine_new_version.outputs.version }}
      current_version: ${{ steps.determine_new_version.outputs.current_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Get latest release info
        id: get_latest_release
        uses: pozetroninc/github-action-get-latest-release@master
        continue-on-error: true  # empty version checked later
        with:
          owner: ${{ github.repository_owner }}
          repo: ${{ github.event.repository.name }}
          token: ${{ secrets.GITHUB_TOKEN }}
          excludes: draft
      - name: Report release info
        if: ${{ inputs.logLevel == 'info' || inputs.logLevel == 'debug' }}
        run: >
          echo "Release: ${{ steps.get_latest_release.outputs.release }},
          Id: ${{ steps.get_latest_release.outputs.id }},
          '${{ steps.get_latest_release.outputs.description }}'"

      # Determine the scope of the changes based on commit messages,
      # looking for comments following Conventional Commits
      - name: Determine scope of changes
        id: determine_change_scope
        run: |
          commits=$(git log \
          ${{ steps.get_latest_release.outputs.release }}..HEAD \
          --pretty=format:"%s")
          echo "$commits" > commits.txt

          if ${{ inputs.logLevel == 'info' || inputs.logLevel == 'debug' }}; then
            cat commits.txt
          fi
          scope="patch"

          if grep -q "BREAKING CHANGE: " commits.txt;
          then
            scope="major"
          elif grep -q -E "^[[:alpha:]]+(\([[:alpha:]]+\))?!: " commits.txt;
          then
            scope="major"
          elif grep -q -E "^feat(\([[:alpha:]]+\))?: " commits.txt;
          then
            scope="minor"
          elif grep -q -E "^(fix|chore|build|ci|docs|style|refactor\
          |perf|test)(\([[:alpha:]]+\))?: " commits.txt;
          then
            scope="patch"
          fi

          echo "scope=$scope" >> $GITHUB_OUTPUT
      - name: Report determined scope
        if: ${{ inputs.logLevel == 'info' || inputs.logLevel == 'debug' }}
        run: >
          echo "Determined that the scope is:
          ${{steps.determine_change_scope.outputs.scope }}"

      - name: Determine version
        id: determine_new_version
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace(`
            "${{ steps.get_latest_release.outputs.release }}"))
          {
            $newVersion = "$($env:DEFAULT_MAJOR_VERSION)"+
              ".$($env:DEFAULT_MINOR_VERSION).$($env:DEFAULT_PATCH_VERSION)";
            echo "version=$newVersion" >> $env:GITHUB_OUTPUT
          }
          else {
            $versionString = "${{ steps.get_latest_release.outputs.release }}"

            $scope = "${{ steps.determine_change_scope.outputs.scope }}"

            if ($versionString -match '^v?(\d+)\.(\d+)\.(\d+)(?:-.+)?$') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]

                $currentVersion = "$major.$minor.$patch";
                Write-Output "current_version=$currentVersion" >> $env:GITHUB_OUTPUT

                switch ($scope) {
                  "major" { $major++; $minor = 0; $patch = 0 }
                  "minor" { $minor++; $patch = 0 }
                  "patch" { $patch++ }
                }

                $newVersion = "$major.$minor.$patch"
                Write-Output "version=$newVersion" >> $env:GITHUB_OUTPUT
            }
            else {
                Write-Error "Version string not in expected format (vX.Y.Z)"
            }
          }
      - name: Report next version
        if: ${{ inputs.logLevel == 'info' || inputs.logLevel == 'debug' }}
        run: >
          echo "Determined that the next version is:
          ${{steps.determine_new_version.outputs.version }}
          (currently
          '${{steps.determine_new_version.outputs.current_version }}')"
